//***************************************************************************
//
//  File Name :		TwiMasterUSI.h
//
//  Project :		TWI (I2C) library for the Atmel 8 bit AVR MCU
//
//  Purpose :		Object orientated access to the Timer 16 bit timers T3, T4, T5 on
//					Atmel 8 bit AVR MCUs
//
// The MIT License (MIT)
//
// Copyright (c) 2013-2016 Andy Burgess
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
//  Revisions :
//
//      see rcs below
//
//***************************************************************************



#ifndef USITWIMASTER_H_
#define USITWIMASTER_H_

#include "twiMasterBase.h"
#include <avr/io.h>
#include <util/delay.h>

#include "CommonDefs.h"
#include "FastIO.h"

#define SYS_CLK		(F_CPU/1000)	// [kHz]
#define TWI_NACK_BIT  0       // Bit position for (N)ACK bit.


class TwiMaster : public TwiMasterBase
{
//variables
public:
protected:
private:
	FastIOOutputPin<SDAPIN> sdaPin;
	FastIOOutputPin<SCLPIN> sclPin;
	static const bool released=true;
	static const bool low=false;
	static const uint8_t tempUSISR_8bit = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Prepare register value to: Clear flags, and
		(0x0<<USICNT0);                                     // set USI to shift 8 bits i.e. count 16 clock edges.
	static const uint8_t tempUSISR_1bit = (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Prepare register value to: Clear flags, and
		(0xE<<USICNT0);                                     // set USI to shift 1 bit i.e. count 2 clock edges.
	bool fast;

//functions
public:
	//! \brief Initialises a new instance of the TwiMaster object
	TwiMaster()
	{
		// Force primary interface (PORTB)
		#if defined (USIPOS)
		_cbi(USIPP, USIPOS);
		#endif

		// Preload dataregister with "released level" data.
		USIDR    =  0xFF;

		USICR    =  (0<<USISIE) | (0<<USIOIE) |			// Disable Interrupts.
			(1<<USIWM1) | (0<<USIWM0) |					// Set USI in Two-wire mode.
			(1<<USICS1) | (0<<USICS0) | (1<<USICLK) |	// Software strobe as counter clock source
			(0<<USITC);

		USISR   =   (1<<USISIF) | (1<<USIOIF) | (1<<USIPF) | (1<<USIDC) |	// Clear flags,
			(0x0<<USICNT0);													// and reset counter.

		sdaPin = released;
		sclPin = released;

		// default to a low speed (100kHz) with a 8MHz clock
		setSpeed(false);
	}

	//void init (/*bool fast,*/ bool pullup);
	void pullups (bool enable);

	//! \brief Sets low or high speed on the I2C bus
	//! \details Enables a caller to set the I2C bus clock
	//! frequency to 100kHz or 400kHz
	//! \param fast Sets 400kHz fast mode when true; otherwise 100kHz.
	inline void setSpeed (bool fast) __attribute__((always_inline))
	{
		this->fast = fast;
	}

protected:
	bool start (uint8_t device, twiDir_t read)
	{
		// A start condition is generated by the master by forcing SDA low
		// while keeping the SCL high
		// On entry, both SCL and SDA should be released
		// Wait for SCL to become high
		// Then take with SDA high, take SCL low
		// Take SDA low and we're done

		// When we leave this method, SCL will be low and SDA should be released (performed in dataTransfer)
		uint8_t	slarw = (device << 1) | read;
		sclPin = released;

		// Verify that SCL becomes high.
		while (!sclPin)
			;
	
		delayHighSCL();

		//  Generate Start Condition
		sdaPin = low;									// Pull SDA low
		delayLowSCL();									// and delay
		sclPin = low;									// before pulling SCL low

		// Write the address byte
		// The USIDR is written before SDA is released to prevent glitches that may occur
		// if the address bit 7 is low.
		USIDR     = slarw;								// Setup data.
		sdaPin = released;								// before releasing the SDA

		dataTransfer(tempUSISR_8bit);					// Send 8 bits on bus.

		// Clock and verify (N)ACK from slave
		// SDA high is a NACK, low is an ACK
		USIDR = 0xff;									// Setup so that SDA is released so

		// that the ACK bit can be seen
		if (dataTransfer(tempUSISR_1bit) & (1<<TWI_NACK_BIT))
		{
			return false;	// NACK
		}

		return true;		// ACK'D
	}

	inline
	bool repeatStart (uint8_t device, twiDir_t read)
	{
		return start(device, read);
	}

	void stop ()
	{
		// A stop condition is generated by the master by releasing SDA whilst SCL is high
		// On entry, the data register should have an FF or FE dependent on the previous ACK/NACK
		// but released and SCL should be low, yet released.
		//USIDR = 0x00;
		sdaPin = low;
		delayLowSCL();
		sclPin = released;

		// Wait for SCL to go high.
		while (!sclPin)
			;

		delayHighSCL();
		sdaPin = released;
		delayLowSCL();
	}


	bool writeDevice (uint8_t data)
	{
		USIDR     = data;								// Setup data.
		dataTransfer(tempUSISR_8bit);					// Send 8 bits on bus.

		// Clock and verify (N)ACK from slave
		// SDA high is a NACK, low is an ACK
		USIDR = 0xff;									// Setup so that SDA is released so

		// that the ACK bit can be seen
		if (dataTransfer(tempUSISR_1bit) & (1<<TWI_NACK_BIT))
		{
			return false;	// NACK
		}

		return true;		// ACK'D
	}


	uint8_t readDeviceWithAck()
	{
		USIDR = 0xFF;								// Load NACK to confirm End Of Transmission.
		uint8_t data = dataTransfer(tempUSISR_8bit);

		USIDR = 0x00;								// Load ACK to signal more bytes.
		dataTransfer(tempUSISR_1bit);
		return data;
	}	// readAck


	uint8_t readDeviceWithNak()
	{
		USIDR = 0xFF;								// Load NACK to confirm End Of Transmission.
		uint8_t data = dataTransfer(tempUSISR_8bit);

		USIDR = 0xFF;								// Load NACK to confirm End Of Transmission.
		dataTransfer(tempUSISR_1bit);
		return data;
	}	// readNak


	inline void waitTransComplete ();

private:
	TwiMaster( const TwiMaster &c );
	TwiMaster& operator=( const TwiMaster &c );


	uint8_t dataTransfer (uint8_t temp)
	{
		/*---------------------------------------------------------------
			Core function for shifting data in and out from the USI.
			Data to be sent has to be placed into the USIDR prior to calling
			this function. Data read, will be return'ed from the function.
		---------------------------------------------------------------*/
		// On entry, the data register is preloaded with the byte to send
		// SCL is low, and SDA is released so that SDA should have bit 7
		// of the data ready for clocking

		// On exit, SDA will be released with the last data and SCL should be low, yet released

		// Set USISR according to temp
		USISR = temp;

		// Prepare clocking.
		temp  =  (0<<USISIE) | (0<<USIOIE) |			// Interrupts disabled
			(1<<USIWM1) | (0<<USIWM0) |					// Set USI in Two-wire mode.
			(1<<USICS1) | (0<<USICS0) | (1<<USICLK) |	// Software clock strobe as source.
			(1<<USITC);									// Toggle Clock Port.

		do
		{
			delayLowSCL();
			USICR = temp;								// Generate positive SCL edge.
			
			// Wait for SCL to go high.
			while (!sclPin)
				;

			delayHighSCL();
			USICR = temp;								// Generate negative SCL edge.
		} while( !(USISR & (1<<USIOIF)) );				// Check for transfer complete.
	
		temp  = USIDR;									// Read out data.
	//	USIDR = 0xFF;									// Release SDA - now done in the calling function

		return temp;
	}


	// high scl clock delay
	inline void delayHighSCL ()
	{
		if (this->fast)
			_delay_us(0.6);
		else
			_delay_us(4.0);
	}

	// low scl clock period
	inline void delayLowSCL ()
	{
		if (this->fast)
			_delay_us(1.3);
		else
			_delay_us(4.7);
	}
};




#endif /* USITWIMASTER_H_ */